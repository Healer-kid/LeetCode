Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

 

Example 1:

Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:

Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:

Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
 

approach 1:
-----------
brute force:

also remember , if you use unique to remove duplicates from 2d vector, then you should sort before, cause unique works only if the duplicates are neighbours.



class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(),nums.end());
        int n=nums.size();
        for(int i=0;i<n-2;i++){
            for(int j=i+1;j<n-1;j++){
                
                for(int k=j+1;k<n;k++){

                    if(nums[i]+nums[j]+nums[k]==0)
                    {
                        ans.push_back({nums[i],nums[j],nums[k]});

                    }
                }
            }
        }

        sort(ans.begin(),ans.end());
        ans.erase(unique(ans.begin(),ans.end()),ans.end());
        return ans;
    }
};

approach 2:
--------------

step 1:
-------

similar to 2 sum ,but we will fix two elements then find the third one in the hashset

why hashset?
find the third element in o(1) time.

why we didn't put the elements in the hashset at first itself?
since the same element will be picked twice
eg) 2,-4,0
if we insert all at first in the hashset, then lets say a=2,b=-4
c=-(2-4)
c=2 -> now it checks in the hashset,it is there, then it will create a solution saying (2,-4,2)
but 2 present only once. [CURRENT ELEMENT CANNOT BE PICKED TWICE]

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        
        set<vector<int>> s;
        sort(nums.begin(),nums.end());
        int n=nums.size();

        for(int i=0;i<n;i++){
            set<int> hs;
            for(int j=i+1;j<n;j++){
                int third=-(nums[i]+nums[j]);
                if(hs.find(third)!=hs.end())
                {
                    vector<int> temp = {nums[i],nums[j],third};
                    sort(temp.begin(),temp.end());
                    s.insert(temp);

                }
                hs.insert(nums[j]);

            }


        }
        vector<vector<int>> ans(s.begin(),s.end());
        return ans;

    }
};


approach 3:
--------------

two pointers

sort the array
fix first value - i 
j-> i+1
k-> n-1

step:
	if target<0,increment j
	if target >0 ,decrement k
	else push the answere and increment j to find the next combo. | check for duplicates of j, if so then move to the next element and keep on moving.


class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());

        for (int i = 0; i < nums.size(); i++) {
            if (i > 0 && nums[i] == nums[i-1]) {   
                continue;
            }
            
            int j = i + 1;
            int k = nums.size() - 1;

            while (j < k) {
                int total = nums[i] + nums[j] + nums[k];

                if (total > 0) {
                    k--;
                } else if (total < 0) {
                    j++;
                } else {
                    res.push_back({nums[i], nums[j], nums[k]});
                    j++;

                    while (nums[j] == nums[j-1] && j < k) {
                        j++;
                    }
                }
            }
        }
        return res;        
    }
};
